levels(sumData_B$Lab) <- c("FF", "Lab_B")
sumData_C$Lab <- factor(sumData_C$Lab)
levels(sumData_C$Lab) <- c("FF", "Lab_C")
sumData_D$Lab <- factor(sumData_D$Lab)
levels(sumData_D$Lab) <- c("FF", "Lab_D")
sumData_E$Lab <- factor(sumData_E$Lab)
levels(sumData_E$Lab) <- c("FF", "Lab_E")
sumData_F$Lab <- factor(sumData_F$Lab)
levels(sumData_F$Lab) <- c("FF", "Lab_F")
sumData_G$Lab <- factor(sumData_G$Lab)
levels(sumData_G$Lab) <- c("FF", "Lab_G")
sumData_H$Lab <- factor(sumData_H$Lab)
levels(sumData_H$Lab) <- c("FF", "Lab_H")
sumData_I$Lab <- factor(sumData_I$Lab)
levels(sumData_I$Lab) <- c("FF", "Lab_I")
sumData_J$Lab <- factor(sumData_J$Lab)
levels(sumData_J$Lab) <- c("FF", "Lab_J")
sumData_K$Lab <- factor(sumData_K$Lab)
levels(sumData_K$Lab) <- c("FF", "Lab_K")
sumData_L$Lab <- factor(sumData_L$Lab)
levels(sumData_L$Lab) <- c("FF", "Lab_L")
sumData_M$Lab <- factor(sumData_M$Lab)
levels(sumData_M$Lab) <- c("FF", "Lab_M")
sumData_N$Lab <- factor(sumData_N$Lab)
levels(sumData_N$Lab) <- c("FF", "Lab_N")
sumData <- rbind(
sumData_A[sumData_A$Lab == "Lab_A", ],
sumData_B[sumData_B$Lab == "Lab_B", ],
sumData_C[sumData_C$Lab == "Lab_C", ],
sumData_D[sumData_D$Lab == "Lab_D", ],
sumData_E[sumData_E$Lab == "Lab_E", ],
sumData_F[sumData_F$Lab == "Lab_F", ],
sumData_G[sumData_G$Lab == "Lab_G", ],
sumData_H[sumData_H$Lab == "Lab_H", ],
sumData_I[sumData_I$Lab == "Lab_I", ],
sumData_J[sumData_J$Lab == "Lab_J", ],
sumData_K[sumData_K$Lab == "Lab_K", ],
sumData_L[sumData_L$Lab == "Lab_L", ],
sumData_M[sumData_M$Lab == "Lab_M", ],
sumData_N[sumData_N$Lab == "Lab_N", ]
)
#### Circular Heatmap for the Minimum Values ####
tmp <- data.frame(sumData[, c("Metabolite", "Lab", "Relative_difference_min")])
tmp2 <- tmp
#tmp2 <- tmp[complete.cases(tmp),]
# <- tmp2[order(tmp2$Relative_difference_max_name),]
tmp2$id <- as.numeric(as.factor(tmp2$Metabolite))
colnames(tmp2) <- c("Metabolite", "lab", "value", "id")
write.csv2(tmp2[order(tmp2$value, decreasing = TRUE),], "RelDiffMin.csv")
tmp2$value <- log2(tmp2$value)
tmp3 <- tmp2[,-4]
tmp4 <- reshape(tmp3, idvar = "Metabolite", timevar = "lab", direction = "wide")
rownames(tmp4) <- tmp4$Metabolite
tmp4 <- as.matrix(tmp4[,-1])
tmp4[is.na(tmp4)] <- -9999
#colnames(tmp4) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
#                    "LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp5 <- tmp4
colnames(tmp4) <- c("LAB N", "LAB M", "LAB L", "LAB K", "LAB J", "LAB I", "LAB H", "LAB G",
"LAB F", "LAB E", "LAB D", "LAB C", "LAB B", "LAB A")
#asıl veriler bunlar, tmp4 heatmap problemini aşmak için tersten oluşturuldu.
colnames(tmp5) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
"LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp4 <- tmp4[order(row.names(tmp4)), ]
tmp5 <- tmp5[order(row.names(tmp5)), ]
write.csv(tmp5, "circos_control_data_min.csv")
rownames(datab) <- datab$Metabolite_ID
datab2 <- datab[rownames(tmp4), ]
# datab2 <- datab[datab$Metabolite_ID %in% rownames(tmp4), ]
# datab2 <- datab2[order(datab2$Metabolite_ID),]
rownames(tmp4) <- datab2$Metabolite_Plot_Name
split = sample(letters[1:5], 561, replace = TRUE)
split = factor(split, levels = letters[1:5])
# split3 <- factor(rep(c("None","CE", "Cer", "None", "DG", "None", "HexCer", "None", "lysoPC", "None", "PC.ae", "None", "SM", "None", "TG.22", "None"),
#            c(36, 22, 32, 8, 18, 23, 34, 10, 14, 6, 73, 9, 15, 7, 239, 15)))
split2 <- factor(datab2$Metabolite_Class_Paper)
install.packages("circlize")
library(circlize) # >= 0.4.10
col_fun1 = colorRamp2(c(0, 0.000001, 5, 10), c("#FFFFFF", "#91cf60", "#ffffbf", "#fc8d59"))
circos.clear()
pdf("Figure_circ_heatmap_min.pdf", width = 15, height = 20)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
circos.par(gap.after = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8))
circos.heatmap(tmp4, split = split2, col = col_fun1, track.height = 0.4, rownames.side = "outside",
bg.border="gray", cell.border = "gray")
circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) {
if(CELL_META$sector.numeric.index == 11) { # the last sector
cn = colnames(tmp4)
n = length(cn)
circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, "mm"),
1:n - 0.5, cn,
cex = 0.5, adj = c(0, 0.5), facing = "inside")
}
}, bg.border = NA)
library(ComplexHeatmap)
lgd = Legend(title = "Relative Difference", col_fun = col_fun1)
grid.draw(lgd)
dev.off()
#### Circular Heatmap for the Median Values ####
tmp <- data.frame(sumData[, c("Metabolite", "Lab", "Relative_difference_median")])
tmp2 <- tmp
#tmp2 <- tmp[complete.cases(tmp),]
# <- tmp2[order(tmp2$Relative_difference_max_name),]
tmp2$id <- as.numeric(as.factor(tmp2$Metabolite))
colnames(tmp2) <- c("Metabolite", "lab", "value", "id")
write.csv2(tmp2[order(tmp2$value, decreasing = TRUE),], "RelDiffMedian.csv")
tmp2$value <- log2(tmp2$value)
tmp3 <- tmp2[,-4]
tmp4 <- reshape(tmp3, idvar = "Metabolite", timevar = "lab", direction = "wide")
rownames(tmp4) <- tmp4$Metabolite
tmp4 <- as.matrix(tmp4[,-1])
tmp4[is.na(tmp4)] <- -9999
#colnames(tmp4) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
#                    "LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp5 <- tmp4
colnames(tmp4) <- c("LAB N", "LAB M", "LAB L", "LAB K", "LAB J", "LAB I", "LAB H", "LAB G",
"LAB F", "LAB E", "LAB D", "LAB C", "LAB B", "LAB A")
#asıl veriler bunlar, tmp4 heatmap problemini aşmak için tersten oluşturuldu.
colnames(tmp5) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
"LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp4 <- tmp4[order(row.names(tmp4)), ]
tmp5 <- tmp5[order(row.names(tmp5)), ]
write.csv(tmp5, "circos_control_data_med.csv")
rownames(datab) <- datab$Metabolite_ID
datab2 <- datab[rownames(tmp4), ]
# datab2 <- datab[datab$Metabolite_ID %in% rownames(tmp4), ]
# datab2 <- datab2[order(datab2$Metabolite_ID),]
rownames(tmp4) <- datab2$Metabolite_Plot_Name
split = sample(letters[1:5], 561, replace = TRUE)
split = factor(split, levels = letters[1:5])
# split3 <- factor(rep(c("None","CE", "Cer", "None", "DG", "None", "HexCer", "None", "lysoPC", "None", "PC.ae", "None", "SM", "None", "TG.22", "None"),
#            c(36, 22, 32, 8, 18, 23, 34, 10, 14, 6, 73, 9, 15, 7, 239, 15)))
split2 <- factor(datab2$Metabolite_Class_Paper)
library(circlize) # >= 0.4.10
col_fun1 = colorRamp2(c(0, 0.000001, 5, 10), c("#FFFFFF", "#91cf60", "#ffffbf", "#fc8d59"))
circos.clear()
pdf("Figure_circ_heatmap_median.pdf", width = 15, height = 20)
circos.par(gap.after = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8))
circos.heatmap(tmp4, split = split2, col = col_fun1, track.height = 0.4, rownames.side = "outside",
bg.border="gray", cell.border = "gray")
circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) {
if(CELL_META$sector.numeric.index == 11) { # the last sector
cn = colnames(tmp4)
n = length(cn)
circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, "mm"),
1:n - 0.5, cn,
cex = 0.5, adj = c(0, 0.5), facing = "inside")
}
}, bg.border = NA)
library(ComplexHeatmap)
lgd = Legend(title = "Relative Difference", col_fun = col_fun1)
grid.draw(lgd)
dev.off()
#### Circular Heatmap for the Maximum Values ####
tmp <- data.frame(sumData[, c("Metabolite", "Lab", "Relative_difference_max")])
tmp2 <- tmp
#tmp2 <- tmp[complete.cases(tmp),]
# <- tmp2[order(tmp2$Relative_difference_max_name),]
tmp2$id <- as.numeric(as.factor(tmp2$Metabolite))
colnames(tmp2) <- c("Metabolite", "lab", "value", "id")
write.csv2(tmp2[order(tmp2$value, decreasing = TRUE),], "RelDiffMax.csv")
tmp2$value <- log2(tmp2$value)
tmp3 <- tmp2[,-4]
tmp4 <- reshape(tmp3, idvar = "Metabolite", timevar = "lab", direction = "wide")
rownames(tmp4) <- tmp4$Metabolite
tmp4 <- as.matrix(tmp4[,-1])
tmp4[is.na(tmp4)] <- -9999
#colnames(tmp4) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
#                    "LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp5 <- tmp4
colnames(tmp4) <- c("LAB N", "LAB M", "LAB L", "LAB K", "LAB J", "LAB I", "LAB H", "LAB G",
"LAB F", "LAB E", "LAB D", "LAB C", "LAB B", "LAB A")
#asıl veriler bunlar, tmp4 heatmap problemini aşmak için tersten oluşturuldu.
colnames(tmp5) <- c("LAB A", "LAB B", "LAB C", "LAB D", "LAB E", "LAB F", "LAB G", "LAB H",
"LAB I", "LAB J", "LAB K", "LAB L", "LAB M", "LAB N")
tmp4 <- tmp4[order(row.names(tmp4)), ]
tmp5 <- tmp5[order(row.names(tmp5)), ]
write.csv(tmp5, "circos_control_data_max.csv")
rownames(datab) <- datab$Metabolite_ID
datab2 <- datab[rownames(tmp4), ]
# datab2 <- datab[datab$Metabolite_ID %in% rownames(tmp4), ]
# datab2 <- datab2[order(datab2$Metabolite_ID),]
rownames(tmp4) <- datab2$Metabolite_Plot_Name
split = sample(letters[1:5], 561, replace = TRUE)
split = factor(split, levels = letters[1:5])
# split3 <- factor(rep(c("None","CE", "Cer", "None", "DG", "None", "HexCer", "None", "lysoPC", "None", "PC.ae", "None", "SM", "None", "TG.22", "None"),
#            c(36, 22, 32, 8, 18, 23, 34, 10, 14, 6, 73, 9, 15, 7, 239, 15)))
split2 <- factor(datab2$Metabolite_Class_Paper)
library(circlize) # >= 0.4.10
col_fun1 = colorRamp2(c(0, 0.000001, 5, 10), c("#FFFFFF", "#91cf60", "#ffffbf", "#fc8d59"))
circos.clear()
pdf("Figure_circ_heatmap_max.pdf", width = 15, height = 20)
circos.par(gap.after = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8))
circos.heatmap(tmp4, split = split2, col = col_fun1, track.height = 0.4, rownames.side = "outside",
bg.border="gray", cell.border = "gray")
circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) {
if(CELL_META$sector.numeric.index == 11) { # the last sector
cn = colnames(tmp4)
n = length(cn)
circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, "mm"),
1:n - 0.5, cn,
cex = 0.5, adj = c(0, 0.5), facing = "inside")
}
}, bg.border = NA)
library(ComplexHeatmap)
lgd = Legend(title = "Relative Difference", col_fun = col_fun1)
grid.draw(lgd)
dev.off()
install.packages("dplyr")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
gc()
set.seed(999)
n = 1000
df <- data.fram(sectors = sample(letters[1:8], n, replace = T), x = rnorm(n), y = runif(n))
df <- data.frame(sectors = sample(letters[1:8], n, replace = T), x = rnorm(n), y = runif(n))
# initialize the circular layout
install.packages("circlize")
install.packages("circlize")
library(circlize)
circos.par("track.height" = .1)
circos.initialize(df$sectors, x = df$x)
circos.par("track.height" = .1)
circos.initialize(df$sectors, x = df$x)
circos.track(df$sectors, y <- df$y,
panel.fun <- function(x, y){
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
}
)
circos.axis(labels.cex <- .6)
circos.track(df$sectors, y <- df$y,
panel.fun <- function(x, y){
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = .6)
}
)
circos.track(df$sectors, y <- df$y,
panel.fun = function(x, y){
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = .6)
}
)
circos.track(df$sectors, y <- df$y,
panel.fun = function(x, y){
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = .6)
}
)
circos.track(df$sectors, y) <- df$y,
circos.track(df$sectors, y = df$y,
panel.fun = function(x, y) {
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
bgcol <- rep(c(("#EFEFEF", "#CCCCCC"), 4)
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.par("track.height" = .1)
circos.initialize(df$sectors, x = df$x)
circos.track(df$sectors, y = df$y,
panel.fun = function(x, y) {
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol)
, col = NA
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)
circos.par("track.height" = .1)
circos.initialize(df$sectors, x = df$x)
circos.track(df$sectors, y = df$y,
panel.fun = function(x, y) {
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol)
circos.par("track.height" = .1)
circos.initialize(df$sectors, x = df$x)
circos.track(df$sectors, y = df$y,
panel.fun = function(x, y) {
circos.text(CELL_META$xcenter,
CELL_META$cell.ylim[2] + mm_y(5),
CELL_META$sector.index)
circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)
circos.lines(x2[od], y2[od])
circos.track(df$sectors, x = df$x, y = df$y,
panel.fun = function(x, y){
ind = sample(length(x), 10)
x2 = x[ind]
y2 = y[ind]
od = order(x2)
circos.lines(x2[od], y2[od])
})
circos.update(sector.index = "d", track.index = 2,
bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2:2, y = rep(0.5, 5), col = "white")
circos.text(CELL_META$xcenter, CELL_META$ycenter, "updated", col= "white")
circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1),
breaks[-1], rep(ylim[2], n_breaks - 1),
col = rand_color(n_breaks), border = NA)
circos.track(ylim = c(0, 1), panel.fun = function(x, y){
xlim = CELL_META$xlim
ylim = CELL_META$ylim
breaks = seq(xlim[1], xlim[2], by = 0.1)
n_breaks = length(breaks)
circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1),
breaks[-1], rep(ylim[2], n_breaks - 1),
col = rand_color(n_breaks), border = NA)
})
circos.link("a", 0, "b", 0, h = 0.4)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5, 0.5), col = "red")
circos.link("e", 0, "g", c(-1, 1), col = "green", border = "purple", border = "orange", lwd = 2, lty = 2)
circos.link("e", 0, "g", c(-1, 1), col = "green", border = "purple", border = "orange", lwd = 2, lty = 2)
circos.link("e", 0, "g", c(-1, 1), col = "purple", border = "darkorange", lwd = 2, lty = 2)
circos.clear()
circos.clear()
setwd("~/GitHub/private_repo/i_files/06062022/studies_circular_heat_map")
circos.initialize(sectors, xlim)
circos.initialize(sectors, xlim)
s1 <- factor(sectors)
# 2.3 Sectors and tracks
sectors <- c("d", "f", "e", "c", "g", "b", "a")
s1 <- factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
s2 <- factor(sectors, levels = sectors)
circos.initialize(s2, xlim = c(0, 1))
# 2.3 Sectors and tracks
sectors <- c("d", "f", "e", "c", "g", "b", "a")
s1 <- factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
sectors = c("d", "f", "e", "c", "g", "b", "a")
s1 = factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
s2 = factor(sectors, levels = sectors)
circos.initialize(s2, xlim = c(0, 1))
# 2.3 Sectors and tracks
sectors = c("d", "f", "e", "c", "g", "b", "a")
s1 = factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
# 2.3 Sectors and tracks
sectors = c("d", "f", "e", "c", "g", "b", "a")
s1 = factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
circos.initialize(s1, xlim = c(0, 1))
s2 = factor(sectors, levels = sectors)
circos.initialize(s2, xlim = c(0, 1))
# CHAPTER 2 - CIRCULAR LAYOUT
install.packages("circlize")
install.packages("circlize")
library(circlize)
# 2.3 Sectors and tracks
sectors = c("d", "f", "e", "c", "g", "b", "a")
s1 = factor(sectors)
circos.initialize(s1, xlim = c(0, 1))
s2 = factor(sectors, levels = sectors)
circos.initialize(s2, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
circos.text(1, seq_along(s1), s1, facing = "inside", niceFacing = TRUE)
circos.initialize(s1, xlim = c(0, 1))
circos.track(sectors, y=y)
# 2.8 other utilities
# 2.8.1 -> circlize() and reverse.circlize()
install.packages("yaml")
library(yaml)
pokemon_list = data$emoji[1: 40]
data = yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list = data$emojis[1: 40]
pokemon_src = sapply(pokemon_list, function(x) x$src)
install.packages("EBImage")
library(EBImage)
library(yaml)
data = yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list = data$emojis[1:40]
pokemon_name = sapply(pokemon_list, function(x) x$name)
pokemon_src = sapply(pokemon_list, function(x) x$src)
library(EBImage)
install.packages('EBImage')
library(yaml)
data = yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list = data$emojis[1:40]
pokemon_name = sapply(pokemon_list, function(x) x$name)
pokemon_src = sapply(pokemon_list, function(x) x$src)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EBImage")
circos.par("points.overflow.warning" = FALSE)
circos.initialize(pokemon_name, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
pos = circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
image = EBImage::readImage(pokemon_src[CELL_META$sector.numeric.index])
circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2),
CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
adj = c(1, 0.5), cex = 0.6)
rasterImage(image,
xleft = pos[1, 1] - 0.05, ybottom = pos[1, 2] - 0.05,
xright = pos[1, 1] + 0.05, ytop = pos[1, 2]+ 0.05)
}, bg.border = 1, track.height = 0.15)
# Load the required libraries
library(yaml)
library(circlize)
library(EBImage)
# Load Pokémon data from the provided URL
data <- yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list <- data$emojis[1:40]
pokemon_name <- sapply(pokemon_list, function(x) x$name)
pokemon_src <- sapply(pokemon_list, function(x) x$src)
# Install and load the EBImage package
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EBImage")
library(EBImage)
# Set circos parameters
circos.par("points.overflow.warning" = FALSE)
# Initialize the circular plot with Pokémon names sorted alphabetically
circos.initialize(sort(pokemon_name), xlim = c(0, 1))
# Define the function for displaying Pokémon images and names
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
pos <- circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
image <- EBImage::readImage(pokemon_src[CELL_META$sector.numeric.index])
circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2),
CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
adj = c(1, 0.5), cex = 0.6)
rasterImage(image,
xleft = pos[1, 1] - 0.05, ybottom = pos[1, 2] - 0.05,
xright = pos[1, 1] + 0.05, ytop = pos[1, 2] + 0.05)
}, bg.border = 1, track.height = 0.15)
library(yaml)
data = yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list = data$emojis[1:40]
pokemon_name = sapply(pokemon_list, function(x) x$name)
pokemon_src = sapply(pokemon_list, function(x) x$src)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EBImage")
circos.par("points.overflow.warning" = FALSE)
circos.initialize(pokemon_name, xlim = c(0, 1))
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
pos = circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
image = EBImage::readImage(pokemon_src[CELL_META$sector.numeric.index])
circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2),
CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
adj = c(1, 0.5), cex = 0.6)
rasterImage(image,
xleft = pos[1, 1] - 0.05, ybottom = pos[1, 2] - 0.05,
xright = pos[1, 1] + 0.05, ytop = pos[1, 2]+ 0.05)
}, bg.border = 1, track.height = 0.15)
# Load the required libraries
library(yaml)
library(circlize)
library(EBImage)
# Load Pokémon data from the provided URL
data <- yaml.load_file("https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml")
pokemon_list <- data$emojis[1:40]
pokemon_name <- sapply(pokemon_list, function(x) x$name)
pokemon_src <- sapply(pokemon_list, function(x) x$src)
# Install and load the EBImage package
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EBImage")
library(EBImage)
# Set circos parameters
circos.par("points.overflow.warning" = FALSE)
# Initialize the circular plot with Pokémon names sorted alphabetically
circos.initialize(sort(pokemon_name), xlim = c(0, 1))
# Define the function for displaying Pokémon images and names
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
pos <- circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
image <- EBImage::readImage(pokemon_src[CELL_META$sector.numeric.index])
circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2),
CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
adj = c(1, 0.5), cex = 0.6)
rasterImage(image,
xleft = pos[1, 1] - 0.05, ybottom = pos[1, 2] - 0.05,
xright = pos[1, 1] + 0.05, ytop = pos[1, 2] + 0.05)
}, bg.border = 1, track.height = 0.15)
